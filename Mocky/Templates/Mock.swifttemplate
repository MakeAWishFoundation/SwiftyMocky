
import Sourcery
import SourceryRuntime

<%# Helper methods -%>
<%

class ParameterWrapper {
    let parameter: MethodParameter 
    init(_ parameter: SourceryRuntime.MethodParameter) {
        self.parameter = parameter
    }

    var wrappedType: String { 
        get { 
            return "Parameter<\(parameter.typeName.name)>"
        }
    }

    var comparator: String {
        get {
            return "guard Parameter.compare(lhs: lhs\(parameter.name.capitalized), rhs: rhs\(parameter.name.capitalized), with: matcher) else { return false }"
        }
    }
}

class MethodWrapper {
    let method: SourceryRuntime.Method 

    init(_ method: SourceryRuntime.Method) {
        self.method = method 
    }

    var prototype: String {
        get {
            if method.parameters.isEmpty {
                return method.shortName
            }
            let params = method.parameters.flatMap { $0.argumentLabel }.joined(separator: "_")
            return "\(method.shortName)__\(params)"
        }   
    }

    var parameters: [ParameterWrapper] {
        get {
            return method.parameters.map { ParameterWrapper($0) }
        }
    }

    var functionPrototype: String {
        get {
            if method.returnTypeName.isVoid {
                return "func \(method.name) "
            } else {
                return "func \(method.name) -> \(method.returnTypeName.name) "
            }
        }
    }

    var invocation: String {
        if method.parameters.isEmpty {
            return "addInvocation(.\(prototype))"
        } else {
            let parameters = method.parameters.map { ".value(\($0.name))" }.joined(separator: ", ")
            return "addInvocation(.\(prototype)(\(parameters)))"
        }
    }

    var returnValue: String {
        guard !method.returnTypeName.isVoid else { return "" }
        if method.parameters.isEmpty {
            return "return methodReturnValue(.\(prototype)) as! \(method.returnTypeName) "
        } else {
            let parameters = method.parameters.map { ".value(\($0.name))" }.joined(separator: ", ")
            return "return methodReturnValue(.\(prototype)(\(parameters))) as! \(method.returnTypeName) "        
        } 
    }

    func methodDeclarationWithParameters() -> String {
        if method.parameters.isEmpty {
            return method.shortName
        }
        let parameters = method.parameters
        .map {  return "Parameter<\($0.typeName.name)>" }
        .joined(separator: ", ")
        .replacingOccurrences(of: "@escaping", with: "")
        return "\(prototype)(\(parameters))"
    }

    var equalCase: String {    
        get {
            if method.parameters.isEmpty {
                return "case (.\(prototype), .\(prototype)):"
            } else {
                let lhsParams = method.parameters.map { "let lhs\($0.name.capitalized)" }.joined(separator: ", ")
                let rhsParams = method.parameters.map { "let rhs\($0.name.capitalized)" }.joined(separator: ", ")
                return "case (.\(prototype)(\(lhsParams)), .\(prototype)(\(rhsParams))):"
            }
        }
    }

    func proxyConstructor() -> String {    
        if method.parameters.isEmpty {
            return "return MethodProxy(method: .\(prototype), returns: willReturn)"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return MethodProxy(method: .\(prototype)(\(parameters)), returns: willReturn)"
        }
    }

    func proxyConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)(willReturn: \(method.returnTypeName)) -> MethodProxy"
        } else {
            let functionParameters = method.parameters.map { "\($0.name): Parameter<\($0.typeName)>" }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters), willReturn: \(method.returnTypeName)) -> MethodProxy"
        }
    }  
}
    
func wrapMethod(_ method: SourceryRuntime.Method) -> MethodWrapper {
    return MethodWrapper(method)
}

func prototype(_ method: SourceryRuntime.Method) -> String {
    let params = method.parameters.flatMap { $0.argumentLabel }.joined(separator: "_")
    return "\(method.shortName)__\(params)"
}
 
-%>

<%# implement variable for Optional types and IUO, for other add marker that you need to implement those yourself in non-genreated code scope-%>
<%# TODO: make examples for all types of properties with different kinds of accesors-%>
<% 
func stubProperty(_ variable: SourceryRuntime.Variable) -> String {
    if variable.isOptional || variable.isImplicitlyUnwrappedOptional {
        return "var \(variable.name): \(variable.typeName)"
    } else {
        return "// var \(variable.name): \(variable.typeName) - not supported"
    }
}
-%>

<% for type in types.all {  
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue } 
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked

    var invocations: [MethodType] = []
    var methodReturnValues: [MethodProxy] = []
    var matcher: Matcher = Matcher.default

    //MARK : <%= aProtocol.name %>
    <%_ for variable in aProtocol.allVariables { %> 
    <%= stubProperty(variable) -%>
    <% } %> <%_ -%>

    <%_ for method in aProtocol.allMethods.map(wrapMethod) { %>
    <%= method.functionPrototype _%> {
        <%= method.invocation _%> 
        <%= method.returnValue _%> 
    }
    <%  } %> <%_ -%>

    enum MethodType {
    <%_ for method in aProtocol.allMethods.map(wrapMethod) { _%>
        case <%= method.methodDeclarationWithParameters() -%>
    <%  } %> 
    <%_ -%>    
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
             <%_ for method in aProtocol.allMethods.map(wrapMethod) { %>
                <%= method.equalCase -%> <% for parameter in method.parameters { %> 
                    <%= parameter.comparator -%> <%  } %> 
                    return true <% } %>
                <%_ -%>
                default: return false   
            }
        }
    }

    struct MethodProxy {
        var method: MethodType 
        var returns: Any? 
        <%_ for method in aProtocol.methods.map(wrapMethod) { %>
        <%= method.proxyConstructorName() -%> {
            <%= method.proxyConstructor() _%>
        }
        <%  } %> <%_ -%> 
    }

    public func methodReturnValue(_ method: MethodType) -> Any? {
        let matched = methodReturnValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.returns
    }

    public func verify(_ method: MethodType, count: UInt = 1, file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method)
        XCTAssert(invocations.count == Int(count), "Expeced: \(count) invocations of `\(method)`, but was: \(invocations.count)", file: file, line: line)
    }

    public func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }

    public func matchingCalls(_ method: MethodType) -> [MethodType] {
        let matchingInvocations = invocations.filter({ (call) -> Bool in
            return MethodType.compareParameters(lhs: call, rhs: method, matcher: matcher)
        })
        return matchingInvocations
    }
    
    public func given(_ method: MethodProxy) {
        methodReturnValues.append(method)
    }

// sourcery:end
<% }
} -%>