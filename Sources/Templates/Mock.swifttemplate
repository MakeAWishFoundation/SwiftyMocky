
#if Mocky
import SwiftyMocky
import XCTest
<%_ if let imported = arguments["import"] as? String { -%>
<%_ %>import <%= imported %>
<%_ } -%>
<%_ if let allimported = arguments["import"] as? [String] { -%>
<%_ for imported in allimported { %>
<%_ %>import <%= imported -%>
<%_ } -%>
<%_ } -%>
<% %>
<%_ if let tested = arguments["testable"] as? String { -%>
<%_ %>@testable import <%= tested %>
<%_ } -%>
<%_ if let alltested = arguments["testable"] as? [String] { -%>
<%_ for tested in alltested { -%>
<%_ %>@testable import <%= tested %>
<%_ } -%>
<%_ } -%>
<% %>
#else
import Sourcery
import SourceryRuntime
#endif

<%_ if let rules = arguments["excludedSwiftLintRules"] as? [String] { -%>
<%_ for rule in rules { -%>
<%_ %>//swiftlint:disable <%= rule %>
<%_ } -%>
<%_ } -%>

<%# Helper methods -%>
<%
func uniques(methods: [SourceryRuntime.Method]) -> [SourceryRuntime.Method] {
    func areSameParams(_ p1: SourceryRuntime.MethodParameter, _ p2: SourceryRuntime.MethodParameter) -> Bool {
        guard p1.argumentLabel == p2.argumentLabel else { return false }
        guard p1.name == p2.name else { return false }
        guard p1.argumentLabel == p2.argumentLabel else { return false }
        guard p1.typeName.name == p2.typeName.name else { return false }
        guard p1.actualTypeName?.name == p2.actualTypeName?.name else { return false }
        return true
    }

    func areSameMethods(_ m1: SourceryRuntime.Method, _ m2: SourceryRuntime.Method) -> Bool {
        guard m1.name != m2.name else { return true }
        guard m1.selectorName == m2.selectorName else { return false }
        guard m1.parameters.count == m2.parameters.count else { return false }

        let p1 = m1.parameters
        let p2 = m2.parameters

        for i in 0..<p1.count {
            if !areSameParams(p1[i],p2[i]) { return false }
        }

        return true
    }

    return methods.reduce([], { (result, element) -> [SourceryRuntime.Method] in
        guard !result.contains(where: { areSameMethods($0,element) }) else { return result }
        return result + [element]
    })
}

func uniques(variables: [SourceryRuntime.Variable]) -> [SourceryRuntime.Variable] {
    return variables.reduce([], { (result, element) -> [SourceryRuntime.Variable] in
        guard !result.contains(where: { $0.name == element.name }) else { return result }
        return result + [element]
    })
}

class ParameterWrapper {
    let parameter: MethodParameter
    init(_ parameter: SourceryRuntime.MethodParameter) {
        self.parameter = parameter
    }

    var wrappedType: String {
        get {
            return "Parameter<\(parameter.typeName.name)>"
        }
    }

    var comparator: String {
        get {
            return "guard Parameter.compare(lhs: lhs\(parameter.name.capitalized), rhs: rhs\(parameter.name.capitalized), with: matcher) else { return false }"
        }
    }
}

class VariableWrapper {
    let variable: SourceryRuntime.Variable
    let scope: String

    var privatePrototypeName: String { return "__\(variable.name)" }

    var getter: String {
        let message = "\(scope) - value for \(variable.name) was not defined"
        return "get { return \(variable.isStatic ? "\(scope)." : "")\(privatePrototypeName).orFail(\"\(message)\") }"
    }
    var setter: String {
        return "set { \(variable.isStatic ? "\(scope)." : "")\(privatePrototypeName) = newValue }"
    }
    var prototype: String {
        let staticModifier = variable.isStatic ? "static " : ""

        return "\(staticModifier)var \(variable.name): \(variable.typeName.name) { \n" +
        "\t\t\(getter)\n" +
        "\t\t\(setter)\n" +
        "\t}"
    }

    var privatePrototype: String {
        let staticModifier = variable.isStatic ? "static " : ""
        return "private \(staticModifier)var \(privatePrototypeName): (\(variable.typeName.unwrappedTypeName))?"
    }

    init(_ variable: SourceryRuntime.Variable, scope: String) {
        self.variable = variable
        self.scope = scope
    }
}

class MethodWrapper {
    private static var registered: [String: Int] = [:]
    private static var suffixes: [String: Int] = [:]

    let method: SourceryRuntime.Method

    private var registrationName: String {
        get {
            var rawName = method.selectorName
                .replacingOccurrences(of: "_", with: "")
                .replacingOccurrences(of: "(", with: "__")
                .replacingOccurrences(of: ")", with: "")

            var parametersNames = method.parameters.map { "\($0.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return rawName
                .replacingOccurrences(of: "___", with: "__")
                .trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
    }
    private var uniqueName: String {
        get {
            var rawName = method.selectorName
            var parametersNames = method.parameters.map { "\($0.name)_of_\($0.typeName.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return rawName
                .trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
    }
    private var nameSuffix: String {
        guard let count = MethodWrapper.registered[registrationName] else { return "" }
        guard count > 1 else { return "" }

        guard let index = MethodWrapper.suffixes[uniqueName] else { return "" }
        return "_\(index)"
    }

    var prototype: String {
        return "\(registrationName)\(nameSuffix)"
    }
    var parameters: [ParameterWrapper] {
        return method.parameters.map { ParameterWrapper($0) }
    }
    var functionPrototype: String {
        let throwing: String = {
            if method.throws {
                return "throws "
            } else if method.rethrows {
                return "rethrows "
            } else {
                return ""
            }
        }()

        if method.isInitializer {
            return "required \(method.name) \(throwing)"
        }
        else if method.returnTypeName.isVoid {
            return "func \(method.name) \(throwing)"
        } else {
            return "func \(method.name) \(throwing)-> \(method.returnTypeName.name) "
        }
    }
    var invocation: String {
        guard !method.isInitializer else { return "" }
        if method.parameters.isEmpty {
            return "addInvocation(.\(prototype))"
        } else {
            let parameters = method.parameters.map { param in
              let typeString = "\(param.actualTypeName ?? param.typeName)"
              let isEscaping = typeString.contains("@escaping")
              let isOptional = (param.actualTypeName ?? param.typeName).isOptional
              if param.isClosure, !isEscaping, !isOptional {
                let type = strip("\(param.typeName)")
                return "Parameter<\(type)>.any"
              } else {
                return ".value(\(param.name))"
              }
            }.joined(separator: ", ")
            return "addInvocation(.\(prototype)(\(parameters)))"
        }
    }
    var returnValue: String {
        guard !method.isInitializer else { return "" }
        guard !method.returnTypeName.isVoid else { return "" }

        let message = "stub return value not specified for \(method.name). Use given"

        if method.parameters.isEmpty {
            return "\n\t\tlet value = methodReturnValue(.\(prototype)) as? \(method.returnTypeName)\n" +
            "\t\treturn value.orFail(\"\(message)\")"
        } else {
            let parameters = method.parameters.map { ".value(\($0.name))" }.joined(separator: ", ")
            return "\n\t\tlet value = methodReturnValue(.\(prototype)(\(parameters))) as? \(method.returnTypeName)\n" +
            "\t\treturn value.orFail(\"\(message)\")"
        }
    }
    var equalCase: String {
        guard !method.isInitializer else { return "" }
        if method.parameters.isEmpty {
            return "case (.\(prototype), .\(prototype)):"
        } else {
            let lhsParams = method.parameters.map { "let lhs\($0.name.capitalized)" }.joined(separator: ", ")
            let rhsParams = method.parameters.map { "let rhs\($0.name.capitalized)" }.joined(separator: ", ")
            return "case (.\(prototype)(\(lhsParams)), .\(prototype)(\(rhsParams))):"
        }
    }
    var intValueCase: String {
        if method.parameters.isEmpty {
            return "case .\(prototype): return 0"
        } else {
            let params = method.parameters.enumerated().map { offset, _ in
                return "p\(offset)"
            }
            let definitions = params.joined(separator: ", ")
            let paramsSum = params.map({ "\($0).intValue" }).joined(separator: " + ")
            return "case let .\(prototype)(\(definitions)): return \(paramsSum)"
        }
    }

    init(_ method: SourceryRuntime.Method) {
        self.method = method
    }

    static func clear() -> String {
        MethodWrapper.registered = [:]
        MethodWrapper.suffixes = [:]
        return ""
    }

    func register() -> String {
        let name = registrationName
        if let count = MethodWrapper.registered[name] {
            MethodWrapper.registered[name] = count + 1
            MethodWrapper.suffixes[uniqueName] = count + 1
        } else {
            MethodWrapper.registered[name] = 1
            MethodWrapper.suffixes[uniqueName] = 1
        }

        return ""
    }

    func methodDeclarationWithParameters() -> String {
        if method.parameters.isEmpty {
            return method.shortName
        }
        let parameters = method.parameters
        .map {  return "Parameter<\(strip($0.typeName.name))>" }
        .joined(separator: ", ")
        .replacingOccurrences(of: "@escaping", with: "")
        return "\(prototype)(\(parameters))"
    }

    func wrappedInMethodType() -> Bool {
        return !method.isInitializer
    }

    func givenConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)(willReturn: \(method.returnTypeName)) -> Given"
        } else {
            let functionParameters = method.parameters.map {
                let paramType = strip("\($0.typeName)")
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                guard argumentLabel != $0.name else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\(paramType)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters), willReturn: \(method.returnTypeName)) -> Given"
        }
    }

    func givenConstructorNameThrows() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)(willThrow: Error) -> Given"
        } else {
            let functionParameters = method.parameters.map {
                let paramType = strip("\($0.typeName)")
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                guard argumentLabel != $0.name else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\(paramType)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters), willThrow: Error) -> Given"
        }
    }

    func givenConstructor() -> String {
        if method.parameters.isEmpty {
            return "return Given(method: .\(prototype), returns: willReturn, throws: nil)"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return Given(method: .\(prototype)(\(parameters)), returns: willReturn, throws: nil)"
        }
    }

    func givenConstructorThrows() -> String {
        if method.parameters.isEmpty {
            return "return Given(method: .\(prototype), returns: nil, throws: willThrow)"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return Given(method: .\(prototype)(\(parameters)), returns: nil, throws: willThrow)"
        }
    }

    func verificationProxyConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)() -> Verify"
        } else {
            let functionParameters = method.parameters.map {
                let paramType = strip("\($0.typeName)")
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                guard argumentLabel != $0.name else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\(paramType)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters)) -> Verify"
        }
    }

    func verificationProxyConstructor() -> String {
        if method.parameters.isEmpty {
            return "return Verify(method: .\(prototype))"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return Verify(method: .\(prototype)(\(parameters)))"
        }
    }

    func performProxyConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)(perform: \(performProxyClosureType())) -> Perform"
        } else {
            let functionParameters = method.parameters.map {
                let paramType = strip("\($0.typeName)")
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                guard argumentLabel != $0.name else {
                    return "\($0.name): Parameter<\(paramType)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\(paramType)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters), perform: \(performProxyClosureType())) -> Perform"
        }
    }

    func performProxyConstructor() -> String {
        if method.parameters.isEmpty {
            return "return Perform(method: .\(prototype), performs: perform)"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return Perform(method: .\(prototype)(\(parameters)), performs: perform)"
        }
    }

    func performProxyClosureType() -> String {
        if method.parameters.isEmpty {
            return "() -> Void"
        } else {
            let parameters = method.parameters
            .map { "\($0.typeName)" }
            .joined(separator: ", ")
            return "(\(parameters)) -> Void"
        }
    }

    func performProxyClosureCall() -> String {
        if method.parameters.isEmpty {
            return "perform?()"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "perform?(\(parameters))"
        }
    }

    func performCall() -> String {
        guard !method.isInitializer else { return "" }
        let type = performProxyClosureType()
        var proxy = ""

        if method.parameters.isEmpty {
            proxy = "\(prototype)"
        } else {
            let parameters = method.parameters.map { param in
              let typeString = "\(param.actualTypeName ?? param.typeName)"
              let isEscaping = typeString.contains("@escaping")
              let isOptional = (param.actualTypeName ?? param.typeName).isOptional
              if param.isClosure, !isEscaping, !isOptional {
                let type = strip("\(param.typeName)")
                return "Parameter<\(type)>.any"
              } else {
                return ".value(\(param.name))"
              }
            }.joined(separator: ", ")
            proxy = "\(prototype)(\(parameters))"
        }

        let cast = "let perform = methodPerformValue(.\(proxy)) as? \(type)"
        let call = performProxyClosureCall()

        return "\n\t\t\(cast)\n\t\t\(call)"
    }

    private func strip(_ type: String) -> String {
        return type.replacingOccurrences(of: "@escaping", with: "").replacingOccurrences(of: "@autoclosure", with: "")
    }
}

func wrapMethod(_ method: SourceryRuntime.Method) -> MethodWrapper {
    return MethodWrapper(method)
}

-%>

<%# implement variable for Optional types and IUO, for other add marker that you need to implement those yourself in non-genreated code scope-%>
<%# TODO: make examples for all types of properties with different kinds of accesors-%>
<%
func stubProperty(_ variable: SourceryRuntime.Variable, _ scope: String) -> String {
    let wrapper = VariableWrapper(variable, scope: scope)
    return "\(wrapper.prototype)\n\t\(wrapper.privatePrototype)"
}
-%>

<%# Mock.generated -%>
<% for type in types.protocols {
    guard type.inheritedTypes.contains("AutoMockable") || type.annotations["AutoMockable"] != nil else { continue }
    let aProtocol = type
     -%>
<%_ %>// MARK: - <%= type.name %>
class <%= type.name %>Mock:<%= type.annotations["ObjcProtocol"] != nil ? " NSObject," : "" %> <%= type.name %>, Mock {
    fileprivate var invocations: [MethodType] = []
    var methodReturnValues: [Given] = []
    var methodPerformValues: [Perform] = []
    var matcher: Matcher = Matcher.default
    <%_ -%>
    <%_ let allVariables = uniques(variables: aProtocol.allVariables) %><%_ -%>
    <%_ let allMethods = uniques(methods: aProtocol.allMethods) %><%_ -%>

    <%_ for variable in allVariables { -%>
    <%= stubProperty(variable,"\(type.name)Mock") %>
    <%_ } %> <%_ -%>
    <%_ -%>
    <%_ MethodWrapper.clear() -%>
    <%_ let wrappedMethods = allMethods.map(wrapMethod).filter({ $0.wrappedInMethodType() }) -%>
    <%_ for method in wrappedMethods { method.register() } -%>

    <%_ for method in allMethods.map(wrapMethod) { -%>
    <%= method.functionPrototype _%> {
        <%= method.invocation _%> <%= method.performCall() _%> <%= method.returnValue _%>
    }

    <%_ } %> <%_ -%>
    <%_ if !wrappedMethods.isEmpty { -%>
    fileprivate enum MethodType {
    <%_ for method in wrappedMethods { -%>
        case <%= method.methodDeclarationWithParameters() _%>
    <%_  } %>
    <%_ -%>
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) { <%_ for method in wrappedMethods { %>
                <%= method.equalCase -%> <% for parameter in method.parameters { %>
                    <%= parameter.comparator -%> <%  } %>
                    return true <% } %>
                <%_ if wrappedMethods.count > 1 { -%>
                default: return false
                <%_ } -%>
            }
        }
    <%_ %>
        func intValue() -> Int {
            switch self { <%_ for method in wrappedMethods { %>
                <%= method.intValueCase -%><% } %>
            }
        }
    }
    <%_ } else { %>
    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }
    <% } -%>

    struct Given {
        fileprivate var method: MethodType
        var returns: Any?
        var `throws`: Any?

        private init(method: MethodType, returns: Any?, throws: Any?) {
            self.method = method
            self.returns = returns
            self.`throws` = `throws`
        }

        <%_ for method in wrappedMethods.filter({ !$0.method.returnTypeName.isVoid && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorName() -%> {
            <%= method.givenConstructor() _%>
        }
        <%_ } -%>
        <%_ for method in wrappedMethods.filter({ $0.method.throws && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorNameThrows() -%> {
            <%= method.givenConstructorThrows() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Verify {
        fileprivate var method: MethodType

        <%_ for method in wrappedMethods { -%>
        <%= method.verificationProxyConstructorName() -%> {
            <%= method.verificationProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        <%_ for method in wrappedMethods { -%>
        <%= method.performProxyConstructorName() -%> {
            <%= method.performProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

    public func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
        methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: UInt = 1, file: StaticString = #file, line: UInt = #line) {
        let method = method.method
        let invocations = matchingCalls(method)
        XCTAssert(invocations.count == Int(count), "Expeced: \(count) invocations of `\(method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }

    private func methodReturnValue(_ method: MethodType) -> Any? {
        let matched = methodReturnValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.returns
    }

    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.performs
    }

    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        let matchingInvocations = invocations.filter({ (call) -> Bool in
            return MethodType.compareParameters(lhs: call, rhs: method, matcher: matcher)
        })
        return matchingInvocations
    }
}
<% } -%>

<%# Inline annotations -%>
<% for type in types.all {
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue }
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked
    <%_ if let rules = arguments["excludedSwiftLintRules"] as? [String] { -%>
    <%_ for rule in rules { -%>
    <%_ %>//swiftlint:disable <%= rule %>
    <%_ } -%>
    <%_ } -%>

    fileprivate var invocations: [MethodType] = []
    var methodReturnValues: [Given] = []
    var methodPerformValues: [Perform] = []
    var matcher: Matcher = Matcher.default
    <%_ -%>
    <%_ let allVariables = uniques(variables: aProtocol.allVariables) %><%_ -%>
    <%_ let allMethods = uniques(methods: aProtocol.allMethods) %><%_ -%>

    //MARK : <%= aProtocol.name %>
    <%_ for variable in allVariables { -%>
    <%= stubProperty(variable,type.name) %>
    <%_ } %> <%_ -%>
    <%_ -%>
    <%_ MethodWrapper.clear() -%>
    <%_ let wrappedMethods = allMethods.map(wrapMethod).filter({ $0.wrappedInMethodType() }) -%>
    <%_ for method in wrappedMethods { method.register() } -%>

    <%_ for method in allMethods.map(wrapMethod) { -%>
    <%= method.functionPrototype _%> {
        <%= method.invocation _%> <%= method.performCall() _%> <%= method.returnValue _%>
    }

    <%_ } %> <%_ -%>
    <%_ if !wrappedMethods.isEmpty { -%>
    fileprivate enum MethodType {
    <%_ for method in wrappedMethods { -%>
        case <%= method.methodDeclarationWithParameters() _%>
    <%_  } %>
    <%_ -%>
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) { <%_ for method in wrappedMethods { %>
                <%= method.equalCase -%> <% for parameter in method.parameters { %>
                <%= parameter.comparator -%> <%  } %>
                    return true <% } %>
                <%_ if wrappedMethods.count > 1 { -%>
                default: return false
                <%_ } -%>
            }
        }
    <%_ %>
        func intValue() -> Int {
            switch self { <%_ for method in wrappedMethods { %>
                <%= method.intValueCase -%><% } %>
            }
        }
    }
    <%_ } else { %>
    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }
    <% } -%>

    struct Given {
        fileprivate var method: MethodType
        var returns: Any?
        var `throws`: Any?

        private init(method: MethodType, returns: Any?, throws: Any?) {
            self.method = method
            self.returns = returns
            self.`throws` = `throws`
        }

        <%_ for method in wrappedMethods.filter({ !$0.method.returnTypeName.isVoid && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorName() -%> {
            <%= method.givenConstructor() _%>
        }
        <%_ } -%>
        <%_ for method in wrappedMethods.filter({ $0.method.throws && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorNameThrows() -%> {
            <%= method.givenConstructorThrows() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Verify {
        fileprivate var method: MethodType

        <%_ for method in wrappedMethods { -%>
        <%= method.verificationProxyConstructorName() -%> {
            <%= method.verificationProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        <%_ for method in wrappedMethods { -%>
        <%= method.performProxyConstructorName() -%> {
            <%= method.performProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

    public func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
        methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: UInt = 1, file: StaticString = #file, line: UInt = #line) {
        let method = method.method
        let invocations = matchingCalls(method)
        XCTAssert(invocations.count == Int(count), "Expeced: \(count) invocations of `\(method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }

    private func methodReturnValue(_ method: MethodType) -> Any? {
        let matched = methodReturnValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.returns
    }

    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.performs
    }

    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        let matchingInvocations = invocations.filter({ (call) -> Bool in
            return MethodType.compareParameters(lhs: call, rhs: method, matcher: matcher)
        })
        return matchingInvocations
    }
// sourcery:end
<% }
} -%>
