
#if MockyCustom
import SwiftyMocky
<%# ================================================== IMPORTS InAPP -%><%_ -%>
    <%_ if let imported = arguments["import"] as? String { -%>
        <%_ %>import <%= imported %>
    <%_ } -%>
    <%_ if let allimported = arguments["import"] as? [String] { -%>
        <%_ for imported in allimported { -%>
            <%_ %>import <%= imported %>
        <%_ } -%>
    <%_ } -%>
    <%_ if let tested = arguments["testable"] as? String { -%>
        <%_ %>@testable import <%= tested %>
    <%_ } -%>
    <%_ if let alltested = arguments["testable"] as? [String] { -%>
        <%_ for tested in alltested { -%>
            <%_ %>@testable import <%= tested %>
        <%_ } -%>
    <%_ } -%>

    public final class MockyAssertion {
        public static var handler: ((Bool, String, StaticString, UInt) -> Void)?
    }

    func MockyAssert(_ expression: @autoclosure () -> Bool, _ message: @autoclosure () -> String = "Verification failed", file: StaticString = #file, line: UInt = #line) {
        guard let handler = MockyAssertion.handler else {
            assert(expression, message, file: file, line: line)
            return
        }

        handler(expression(), message(), file, line)
    }
#elseif Mocky
import SwiftyMocky
import XCTest
<%# ================================================== IMPORTS -%><%_ -%>
    <%_ if let imported = arguments["import"] as? String { -%>
        <%_ %>import <%= imported %>
    <%_ } -%>
    <%_ if let allimported = arguments["import"] as? [String] { -%>
        <%_ for imported in allimported { -%>
            <%_ %>import <%= imported %>
        <%_ } -%>
    <%_ } -%>
    <%_ if let tested = arguments["testable"] as? String { -%>
        <%_ %>@testable import <%= tested %>
    <%_ } -%>
    <%_ if let alltested = arguments["testable"] as? [String] { -%>
        <%_ for tested in alltested { -%>
            <%_ %>@testable import <%= tested %>
        <%_ } -%>
    <%_ } -%>

    func MockyAssert(_ expression: @autoclosure () -> Bool, _ message: @autoclosure () -> String = "Verification failed", file: StaticString = #file, line: UInt = #line) {
        XCTAssert(expression(), message(), file: file, line: line)
    }
#else
import Sourcery
import SourceryRuntime
#endif

<%# ================================================== SwiftLint -%><%_ -%>
<%_ if let rules = arguments["excludedSwiftLintRules"] as? [String] { -%>
    <%_ for rule in rules { -%>
    <%_ %>//swiftlint:disable <%= rule %>
    <%_ } -%>
<%_ } -%>

<%# ================================================== HELPERS -%><%_
    class Current {
        static var selfType: String = "Self"
    }

    class TypeWrapper {
        let type: SourceryRuntime.TypeName

        var unwrapped: String {
            return type.unwrappedTypeName
        }
        var unwrappedReplacingSelf: String {
            return replacingSelf(unwrap: true)
        }
        var stripped: String {
            if type.isImplicitlyUnwrappedOptional {
                return type.isClosure ? "(\(unwrappedReplacingSelf))!" : "\(unwrappedReplacingSelf)!"
            } else if type.isOptional {
                return type.isClosure ? "(\(unwrappedReplacingSelf))?" : "\(unwrappedReplacingSelf)?"
            } else {
                return unwrappedReplacingSelf
            }
        }
        var nestedParameter: String {
            if type.isImplicitlyUnwrappedOptional {
                return "Parameter<" + (type.isClosure ? "(\(unwrappedReplacingSelf))?" : "\(unwrappedReplacingSelf)?") + ">"
            } else if type.isOptional {
                return "Parameter<" + (type.isClosure ? "(\(unwrappedReplacingSelf))?" : "\(unwrappedReplacingSelf)?") + ">"
            } else {
                return "Parameter<\(unwrappedReplacingSelf)>"
            }
        }
        var isSelfType: Bool {
            return unwrapped == "Self"
        }
        func isSelfTypeRecursive() -> Bool {
            if let tuple = type.tuple {
                for element in tuple.elements {
                    guard !TypeWrapper(element.typeName).isSelfTypeRecursive() else { return true }
                }
            } else if let array = type.array {
                return TypeWrapper(array.elementTypeName).isSelfTypeRecursive()
            } else if let dictionary = type.dictionary {
                guard !TypeWrapper(dictionary.valueTypeName).isSelfTypeRecursive() else { return true }
                guard !TypeWrapper(dictionary.keyTypeName).isSelfTypeRecursive() else { return true }
            } else if let closure = type.closure {
                guard !TypeWrapper(closure.actualReturnTypeName).isSelfTypeRecursive() else { return true }
                for parameter in closure.parameters {
                    guard !TypeWrapper(parameter.typeName).isSelfTypeRecursive() else { return true }
                }
            }

            return isSelfType
        }

        init(_ type: SourceryRuntime.TypeName) {
            self.type = type
        }

        func isGeneric(_ types: [String]) -> Bool {
            guard !type.isVoid else { return false }

            func containsType(_ type: String) -> Bool {
                return types.contains(where: {
                    "\($0).Type" == type
                })
            }

            if types.contains(unwrapped) || containsType(unwrapped) {
                return true
            } else if let tuple = type.tuple {
                for element in tuple.elements {
                    guard !TypeWrapper(element.typeName).isGeneric(types) else { return true }
                }
            } else if let array = type.array {
                return TypeWrapper(array.elementTypeName).isGeneric(types)
            } else if let dictionary = type.dictionary {
                guard !TypeWrapper(dictionary.valueTypeName).isGeneric(types) else { return true }
                guard !TypeWrapper(dictionary.keyTypeName).isGeneric(types) else { return true }
            } else if let closure = type.closure {
                guard !TypeWrapper(closure.actualReturnTypeName).isGeneric(types) else { return true }
                for parameter in closure.parameters {
                    guard !ParameterWrapper(parameter).isGeneric(types) else { return true }
                }
            }

            return false
        }

        func replacingSelf(unwrap: Bool = false) -> String {
            guard isSelfTypeRecursive() else {
                return unwrap ? self.unwrapped : "\(type)"
            }

            if isSelfType {
                let optionality: String = {
                    if type.isImplicitlyUnwrappedOptional {
                        return "!"
                    } else if type.isOptional {
                        return "?"
                    } else {
                        return ""
                    }
                }()
                return unwrap ? Current.selfType : Current.selfType + optionality
            } else if let tuple = type.tuple {
                let inner = tuple.elements.map({ TypeWrapper($0.typeName).replacingSelf() }).joined(separator: ",")
                let value = "(\(inner))"
                return value
            } else if let array = type.array {
                let value = "[\(TypeWrapper(array.elementTypeName).replacingSelf())]"
                return value
            } else if let dictionary = type.dictionary {
                let value = "[" +
                "\(TypeWrapper(dictionary.valueTypeName).replacingSelf())"
                + ":" +
                "\(TypeWrapper(dictionary.keyTypeName).replacingSelf())"
                + "]"
                return value
            } else if let closure = type.closure {
                let returnType = TypeWrapper(closure.actualReturnTypeName).replacingSelf()
                let inner = closure.parameters.map({ TypeWrapper($0.typeName).replacingSelf() }).joined(separator: ",")
                let throwing = closure.throws ? "throws " : ""
                let value = "(\(inner)) \(throwing)-> \(returnType)"
                return value
            }

            return unwrap ? self.unwrapped : "\(type)"
        }
    }

    class ParameterWrapper {
        let parameter: MethodParameter

        var wrappedForCall: String {
            let typeString = "\(type.actualTypeName ?? type)"
            let isEscaping = typeString.contains("@escaping")
            let isOptional = (type.actualTypeName ?? type).isOptional
            if parameter.isClosure && !isEscaping && !isOptional {
                return "\(nestedType).any"
            } else {
                return "\(nestedType).value(\(name))"
            }
        }
        var wrappedType: String {
            return "Parameter<\(TypeWrapper(type).stripped)>"
        }
        var nestedType: String {
            return "\(TypeWrapper(type).nestedParameter)"
        }
        var justType: String {
            return "\(TypeWrapper(type).replacingSelf())"
        }
        var genericType: String {
            return "Parameter<GenericAttribute>"
        }
        var type: SourceryRuntime.TypeName {
            return parameter.typeName
        }
        var name: String {
            return parameter.name
        }
        var comparator: String {
            return "guard Parameter.compare(lhs: lhs\(parameter.name.capitalized), rhs: rhs\(parameter.name.capitalized), with: matcher) else { return false }"
        }

        init(_ parameter: SourceryRuntime.MethodParameter) {
            self.parameter = parameter
        }

        func isGeneric(_ types: [String]) -> Bool {
            return TypeWrapper(type).isGeneric(types)
        }

        func wrappedForProxy(_ generics: [String]) -> String {
            return isGeneric(generics) ? "\(name).wrapAsGeneric()" : "\(name)"
        }

        func wrappedForCalls(_ generics: [String]) -> String {
            return isGeneric(generics) ? "\(wrappedForCall).wrapAsGeneric()" : "\(wrappedForCall)"
        }
    }

    class VariableWrapper {
        let variable: SourceryRuntime.Variable
        let scope: String

        var privatePrototypeName: String { return "__\(variable.name)" }

        var getter: String {
            let message = "\(scope) - value for \(variable.name) was not defined"
            let orFail = !(variable.isOptional && !variable.isImplicitlyUnwrappedOptional) ? ".orFail(\"\(message)\")" : ""
            let staticModifier = variable.isStatic ? "\(scope)." : ""
            return "get {\t\(staticModifier)invocations.append(.\(propertyCaseGetName))" + "\n\t\t\t\treturn \(staticModifier)\(privatePrototypeName)\(orFail) }"
        }
        var setter: String {
            let staticModifier = variable.isStatic ? "\(scope)." : ""
            return "set {\t\(staticModifier)invocations.append(.\(propertyCaseSetName)(.value(newValue)))" + "\n\t\t\t\t\(variable.isStatic ? "\(scope)." : "")\(privatePrototypeName) = newValue }"
        }
        var prototype: String {
            let staticModifier = variable.isStatic ? "static " : ""

            return "\(staticModifier)var \(variable.name): \(variable.typeName.name) { \n" +
            "\t\t\(getter)\n" +
            "\t\t\(setter)\n" +
            "\t}"
        }

        var privatePrototype: String {
            let staticModifier = variable.isStatic ? "static " : ""
            return "private \(staticModifier)var \(privatePrototypeName): (\(variable.typeName.unwrappedTypeName))?"
        }
        var nestedType: String {
            return "\(TypeWrapper(variable.typeName).nestedParameter)"
        }

        init(_ variable: SourceryRuntime.Variable, scope: String) {
            self.variable = variable
            self.scope = scope
        }

        func propertyGet() -> String {
            let staticModifier = variable.isStatic ? "Static" : ""
            return "static var \(variable.name): \(staticModifier)Property { return \(staticModifier)Property(method: .\(propertyCaseGetName)) }"
        }

        func propertySet() -> String {
            let staticModifier = variable.isStatic ? "Static" : ""
            return "static func \(variable.name)(set newValue: \(nestedType)) -> \(staticModifier)Property { return \(staticModifier)Property(method: .\(propertyCaseSetName)(newValue)) }"
        }

        var propertyCaseGetName: String { return "\(variable.name)_get" }
        func propertyCaseGet() -> String {
            return "case \(propertyCaseGetName)"
        }
        func propertyCaseGetCompare() -> String {
            return "case (.\(propertyCaseGetName),.\(propertyCaseGetName)): return true"
        }
        func propertyCaseGetIntValue() -> String {
            return "case .\(propertyCaseGetName): return 0"
        }

        var propertyCaseSetName: String { return "\(variable.name)_set" }
        func propertyCaseSet() -> String {
            return "case \(propertyCaseSetName)(\(nestedType))"
        }
        func propertyCaseSetCompare() -> String {
            return "case (.\(propertyCaseSetName)(let left),.\(propertyCaseSetName)(let right)): return \(nestedType).compare(lhs: left, rhs: right, with: matcher)"
        }
        func propertyCaseSetIntValue() -> String {
            return "case .\(propertyCaseSetName)(let newValue): return newValue.intValue"
        }
    }

    class MethodWrapper {
        private static var registered: [String: Int] = [:]
        private static var suffixes: [String: Int] = [:]
        private static var suffixesWithoutReturnType: [String: Int] = [:]

        let method: SourceryRuntime.Method

        private var registrationName: String {
            var rawName = (method.isStatic ? "s\(method.selectorName)" : "i\(method.selectorName)")
                .replacingOccurrences(of: "_", with: "")
                .replacingOccurrences(of: "(", with: "__")
                .replacingOccurrences(of: ")", with: "")
            var parametersNames = method.parameters.map { "\($0.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return  rawName.replacingOccurrences(of: "___", with: "__").trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
        private var uniqueName: String {
            var rawName = (method.isStatic ? "s\(method.selectorName)" : "i\(method.selectorName)")
            var parametersNames = method.parameters.map { "\($0.name)_of_\($0.typeName.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return rawName.trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
        private var uniqueNameWithReturnType: String {
            let returnTypeRaw = "\(method.returnTypeName)"
            var returnTypeStripped: String = {
                guard let range = returnTypeRaw.range(of: "where") else { return returnTypeRaw }
                var stripped = returnTypeRaw
                stripped.removeSubrange((range.lowerBound)...)
                return stripped
            }()
            returnTypeStripped = returnTypeStripped.trimmingCharacters(in: CharacterSet(charactersIn: " "))
            return "\(uniqueName)->\(returnTypeStripped)"
        }
        private var nameSuffix: String {
            guard let count = MethodWrapper.registered[registrationName] else { return "" }
            guard count > 1 else { return "" }
            guard let index = MethodWrapper.suffixes[uniqueNameWithReturnType] else { return "" }
            return "_\(index)"
        }

        var prototype: String {
            return "\(registrationName)\(nameSuffix)"
        }
        var parameters: [ParameterWrapper] {
            return method.parameters.map { ParameterWrapper($0) }
        }
        var functionPrototype: String {
            let throwing: String = {
                if method.throws {
                    return "throws "
                } else if method.rethrows {
                    return "rethrows "
                } else {
                    return ""
                }
            }()
            let staticModifier: String = method.isStatic ? "static " : ""

            if method.isInitializer {
                return "required \(method.name) \(throwing)"
            }
            else if method.returnTypeName.isVoid {
                return "\(staticModifier)func \(method.shortName)(\(parametersForStubSignature())) \(throwing)"
            } else {
                return "\(staticModifier)func \(method.shortName)(\(parametersForStubSignature())) \(throwing)-> \(method.returnTypeName.name) "
            }
        }
        var invocation: String {
            guard !method.isInitializer else { return "" }
            if method.parameters.isEmpty {
                return "addInvocation(.\(prototype))"
            } else {
                return "addInvocation(.\(prototype)(\(parametersForMethodCall())))"
            }
        }
        var givenValue: String {
            guard !method.isInitializer else { return "" }
            guard method.throws || !method.returnTypeName.isVoid else { return "" }

            if method.parameters.isEmpty {
                return "\n\t\tlet givenValue: (value: Any?, error: Error?) = methodReturnValue(.\(prototype))"
            } else {
                return "\n\t\tlet givenValue: (value: Any?, error: Error?) = methodReturnValue(.\(prototype)(\(parametersForMethodCall())))"
            }
        }
        var throwValue: String {
            guard !method.isInitializer, method.throws else { return "" }

            return "\n\t\tif let error = givenValue.error { throw error }"
        }
        var returnValue: String {
            guard !method.isInitializer else { return "" }
            guard !method.returnTypeName.isVoid else { return "" }

            let message = "stub return value not specified for \(method.name). Use given"
            let returnType: String = {
                if returnsSelf {
                    return "__Self__"
                } else {
                    return "\(TypeWrapper(method.returnTypeName).stripped)"
                }
            }()

            return "\n\t\tlet value = givenValue.value as? \(returnType)\n" +
            "\t\treturn value.orFail(\"\(message)\")"
        }
        var equalCase: String {
            guard !method.isInitializer else { return "" }
            if method.parameters.isEmpty {
                return "case (.\(prototype), .\(prototype)):"
            } else {
                let lhsParams = method.parameters.map { "let lhs\($0.name.capitalized)" }.joined(separator: ", ")
                let rhsParams = method.parameters.map { "let rhs\($0.name.capitalized)" }.joined(separator: ", ")
                return "case (.\(prototype)(\(lhsParams)), .\(prototype)(\(rhsParams))):"
            }
        }
        var intValueCase: String {
            if method.parameters.isEmpty {
                return "case .\(prototype): return 0"
            } else {
                let params = method.parameters.enumerated().map { offset, _ in
                    return "p\(offset)"
                }
                let definitions = params.joined(separator: ", ")
                let paramsSum = params.map({ "\($0).intValue" }).joined(separator: " + ")
                return "case let .\(prototype)(\(definitions)): return \(paramsSum)"
            }
        }

        var returnsSelf: Bool {
            return !method.returnTypeName.isVoid && TypeWrapper(method.returnTypeName).isSelfType
        }
        var replaceSelf: String { return Current.selfType }

        init(_ method: SourceryRuntime.Method) {
            self.method = method
        }

        static func clear() -> String {
            MethodWrapper.registered = [:]
            MethodWrapper.suffixes = [:]
            MethodWrapper.suffixesWithoutReturnType = [:]
            return ""
        }

        func register() {
            MethodWrapper.register(registrationName,uniqueName,uniqueNameWithReturnType)
        }

        static func register(_ name: String, _ uniqueName: String, _ uniqueNameWithReturnType: String) {
            if let count = MethodWrapper.registered[name] {
                MethodWrapper.registered[name] = count + 1
                MethodWrapper.suffixes[uniqueNameWithReturnType] = count + 1
            } else {
                MethodWrapper.registered[name] = 1
                MethodWrapper.suffixes[uniqueNameWithReturnType] = 1
            }

            if let count = MethodWrapper.suffixesWithoutReturnType[uniqueName] {
                MethodWrapper.suffixesWithoutReturnType[uniqueName] = count + 1
            } else {
                MethodWrapper.suffixesWithoutReturnType[uniqueName] = 1
            }
        }

        func returnTypeMatters() -> Bool {
            let count = MethodWrapper.suffixesWithoutReturnType[uniqueName] ?? 0
            return count > 1
        }

        func wrappedInMethodType() -> Bool {
            return !method.isInitializer
        }

        func returningParameter(_ multiple: Bool, _ front: Bool) -> String {
            guard returnTypeMatters() else { return "" }
            let returning: String = "returning: \(returnTypeStripped(method, type: true))"
            guard multiple else { return returning }

            return front ? ", \(returning)" : "\(returning), "
        }

        // Stub
        func stubBody() -> String {
            if method.isInitializer || !returnsSelf {
                return invocation + performCall() + givenValue + throwValue + returnValue
            } else {
                return wrappedStubPrefix()
                    + "\t\t" + invocation
                    + performCall()
                    + givenValue
                    + throwValue
                    + returnValue
                    + wrappedStubPostfix()
            }
        }

        func wrappedStubPrefix() -> String {
            guard !method.isInitializer, returnsSelf else {
                return ""
            }

            let throwing: String = {
                if method.throws {
                    return "throws "
                } else if method.rethrows {
                    return "rethrows "
                } else {
                    return ""
                }
            }()

            return "func _wrapped<__Self__>() -> __Self__ {\n"
        }

        func wrappedStubPostfix() -> String {
            guard !method.isInitializer, returnsSelf else {
                return ""
            }

            let throwing: Bool = method.throws || method.rethrows

            return "\n\t\t}"
            + "\n\t\treturn _wrapped()"
        }

        // Method Type
        func methodTypeDeclarationWithParameters() -> String {
            guard !method.parameters.isEmpty else { return "\(prototype)" }
            return "\(prototype)(\(parametersForMethodTypeDeclaration()))"
        }

        // Given
        func givenConstructorName(prefix: String = "") -> String {
            let returnType = returnsSelf ? replaceSelf : TypeWrapper(method.returnTypeName).stripped

            if method.parameters.isEmpty {
                return "static func \(method.shortName)(willReturn: \(returnType)) -> \(prefix)Given"
            } else {
                return "static func \(method.shortName)(\(parametersForProxySignature()), willReturn: \(returnType)) -> \(prefix)Given"
            }
        }

        func givenConstructorNameThrows(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "static func \(method.shortName)(willThrow: Error) -> \(prefix)Given"
            } else {
                return "static func \(method.shortName)(\(parametersForProxySignature()), willThrow: Error) -> \(prefix)Given"
            }
        }

        func givenConstructor(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "return \(prefix)Given(method: .\(prototype), returns: willReturn, throws: nil)"
            } else {
                return "return \(prefix)Given(method: .\(prototype)(\(parametersForProxyInit())), returns: willReturn, throws: nil)"
            }
        }

        func givenConstructorThrows(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "return \(prefix)Given(method: .\(prototype), returns: nil, throws: willThrow)"
            } else {
                return "return \(prefix)Given(method: .\(prototype)(\(parametersForProxyInit())), returns: nil, throws: willThrow)"
            }
        }

        // Verify
        func verificationProxyConstructorName(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "static func \(method.callName)\(wrapGenerics(getGenericsAmongParameters()))(\(returningParameter(false,true))) -> \(prefix)Verify"
            } else {
                return "static func \(method.callName)\(wrapGenerics(getGenericsAmongParameters()))(\(parametersForProxySignature())\(returningParameter(true,true))) -> \(prefix)Verify"
            }
        }

        func verificationProxyConstructor(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "return \(prefix)Verify(method: .\(prototype))"
            } else {
                return "return \(prefix)Verify(method: .\(prototype)(\(parametersForProxyInit())))"
            }
        }

        // Perform
        func performProxyConstructorName(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "static func \(method.callName)\(wrapGenerics(getGenericsAmongParameters()))(\(returningParameter(true,false))perform: \(performProxyClosureType())) -> \(prefix)Perform"
            } else {
                return "static func \(method.callName)\(wrapGenerics(getGenericsAmongParameters()))(\(parametersForProxySignature()), \(returningParameter(true,false))perform: \(performProxyClosureType())) -> \(prefix)Perform"
            }
        }

        func performProxyConstructor(prefix: String = "") -> String {
            if method.parameters.isEmpty {
                return "return \(prefix)Perform(method: .\(prototype), performs: perform)"
            } else {
                return "return \(prefix)Perform(method: .\(prototype)(\(parametersForProxyInit())), performs: perform)"
            }
        }

        func performProxyClosureType() -> String {
            if method.parameters.isEmpty {
                return "() -> Void"
            } else {
                let parameters = self.parameters
                .map { "\($0.justType)" }
                .joined(separator: ", ")
                return "(\(parameters)) -> Void"
            }
        }

        func performProxyClosureCall() -> String {
            if method.parameters.isEmpty {
                return "perform?()"
            } else {
                let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
                return "perform?(\(parameters))"
            }
        }

        func performCall() -> String {
            guard !method.isInitializer else { return "" }
            let type = performProxyClosureType()
            var proxy = method.parameters.isEmpty ? "\(prototype)" : "\(prototype)(\(parametersForMethodCall()))"

            let cast = "let perform = methodPerformValue(.\(proxy)) as? \(type)"
            let call = performProxyClosureCall()

            return "\n\t\t\(cast)\n\t\t\(call)"
        }

        // Helpers
        private func parametersForMethodCall() -> String {
            let generics = getGenerics()
            return parameters.map { $0.wrappedForCalls(generics) }.joined(separator: ", ")
        }

        private func parametersForMethodTypeDeclaration() -> String {
            let generics = getGenerics()
            return parameters.map { param in
                return param.isGeneric(generics) ? param.genericType : param.nestedType
            }.joined(separator: ", ")
        }

        private func parametersForProxySignature() -> String {
            return parameters.map { p in
                guard let argumentLabel = p.parameter.argumentLabel else { return "\(p.name): \(p.nestedType)" }
                guard argumentLabel != p.name else { return "\(p.name): \(p.nestedType)" }
                return "\(argumentLabel) \(p.name): \(p.nestedType)"
            }.joined(separator: ", ")
        }

        private func parametersForStubSignature() -> String {
            return parameters.map { p in
                guard let argumentLabel = p.parameter.argumentLabel else { return "_ \(p.name): \(p.justType)" }
                guard argumentLabel != p.name else { return "\(p.name): \(p.justType)" }
                return "\(argumentLabel) \(p.name): \(p.justType)"
            }.joined(separator: ", ")
        }

        private func parametersForProxyInit() -> String {
            let generics = getGenerics()
            return parameters.map { "\($0.wrappedForProxy(generics))" }.joined(separator: ", ")
        }

        private func isGeneric() -> Bool {
            return method.shortName.contains("<") && method.shortName.contains(">")
        }

        private func getGenerics() -> [String] {
            let name = method.shortName
            guard let start = name.index(of: "<"), let end = name.index(of: ">") else { return [] }

            var genPart = name[start...end]
            genPart.removeFirst()
            genPart.removeLast()

            let parts = genPart.replacingOccurrences(of: " ", with: "").characters.split(separator: ",").map(String.init)
            return parts.map { stripGenPart(part: $0) }
        }

        private func getGenericsAmongParameters() -> [String] {
            return getGenerics().filter {
                for param in self.parameters {
                    if param.isGeneric([$0]) { return true }
                }
                return false
            }
        }

        private func wrapGenerics(_ generics: [String]) -> String {
            guard !generics.isEmpty else { return "" }
            return "<\(generics.joined(separator:","))>"
        }

        private func stripGenPart(part: String) -> String {
            return part.characters.split(separator: ":").map(String.init).first!
        }

        private func returnTypeStripped(_ method: SourceryRuntime.Method, type: Bool = false) -> String {
            let returnTypeRaw = "\(method.returnTypeName)"
            var stripped: String = {
                guard let range = returnTypeRaw.range(of: "where") else { return returnTypeRaw }
                var stripped = returnTypeRaw
                stripped.removeSubrange((range.lowerBound)...)
                return stripped
            }()
            stripped = stripped.trimmingCharacters(in: CharacterSet(charactersIn: " "))
            guard type else { return stripped }
            return "\(stripped).Type"
        }
    }

    func uniques(methods: [SourceryRuntime.Method]) -> [SourceryRuntime.Method] {
        func returnTypeStripped(_ method: SourceryRuntime.Method) -> String {
            let returnTypeRaw = "\(method.returnTypeName)"
            var stripped: String = {
                guard let range = returnTypeRaw.range(of: "where") else { return returnTypeRaw }
                var stripped = returnTypeRaw
                stripped.removeSubrange((range.lowerBound)...)
                return stripped
            }()
            stripped = stripped.trimmingCharacters(in: CharacterSet(charactersIn: " "))
            return stripped
        }

        func areSameParams(_ p1: SourceryRuntime.MethodParameter, _ p2: SourceryRuntime.MethodParameter) -> Bool {
            guard p1.argumentLabel == p2.argumentLabel else { return false }
            guard p1.name == p2.name else { return false }
            guard p1.argumentLabel == p2.argumentLabel else { return false }
            guard p1.typeName.name == p2.typeName.name else { return false }
            guard p1.actualTypeName?.name == p2.actualTypeName?.name else { return false }
            return true
        }

        func areSameMethods(_ m1: SourceryRuntime.Method, _ m2: SourceryRuntime.Method) -> Bool {
            guard m1.name != m2.name else { return returnTypeStripped(m1) == returnTypeStripped(m2) }
            guard m1.selectorName == m2.selectorName else { return false }
            guard m1.parameters.count == m2.parameters.count else { return false }

            let p1 = m1.parameters
            let p2 = m2.parameters

            for i in 0..<p1.count {
                if !areSameParams(p1[i],p2[i]) { return false }
            }

            return returnTypeStripped(m1) == returnTypeStripped(m2)
        }

        return methods.reduce([], { (result, element) -> [SourceryRuntime.Method] in
            guard !result.contains(where: { areSameMethods($0,element) }) else { return result }
            return result + [element]
        })
    }

    func uniques(variables: [SourceryRuntime.Variable]) -> [SourceryRuntime.Variable] {
        return variables.reduce([], { (result, element) -> [SourceryRuntime.Variable] in
            guard !result.contains(where: { $0.name == element.name }) else { return result }
            return result + [element]
        })
    }

    func wrapMethod(_ method: SourceryRuntime.Method) -> MethodWrapper {
        return MethodWrapper(method)
    }

    func stubProperty(_ variable: SourceryRuntime.Variable, _ scope: String) -> String {
        let wrapper = VariableWrapper(variable, scope: scope)
        return "\(wrapper.prototype)\n\t\(wrapper.privatePrototype)"
    }

    func propertyTypes(_ variable: SourceryRuntime.Variable) -> String {
        let wrapper = VariableWrapper(variable, scope: "scope")
        return "\(wrapper.propertyGet())\n\t\t\(wrapper.propertySet())"
    }

    func propertyMethodTypes(_ variable: SourceryRuntime.Variable) -> String {
        let wrapper = VariableWrapper(variable, scope: "")
        return "\(wrapper.propertyCaseGet())\n\t\t\(wrapper.propertyCaseSet())"
    }

    func propertyMethodTypesCompare(_ variable: SourceryRuntime.Variable) -> String {
        let wrapper = VariableWrapper(variable, scope: "")
        return "\(wrapper.propertyCaseGetCompare())\n\t\t\t\t\(wrapper.propertyCaseSetCompare())"
    }

    func propertyMethodTypesIntValue(_ variable: SourceryRuntime.Variable) -> String {
        let wrapper = VariableWrapper(variable, scope: "")
        return "\(wrapper.propertyCaseGetIntValue())\n\t\t\t\t\(wrapper.propertyCaseSetIntValue())"
    }

    func propertyRegister(_ variable: SourceryRuntime.Variable) {
        let wrapper = VariableWrapper(variable, scope: "")
        MethodWrapper.register(wrapper.propertyCaseGetName,wrapper.propertyCaseGetName,wrapper.propertyCaseGetName)
        MethodWrapper.register(wrapper.propertyCaseSetName,wrapper.propertyCaseSetName,wrapper.propertyCaseGetName)
    }
-%>

<%# ================================================== SETUP -%><%_ -%>
<%_ var all = types.all
    all += types.protocols.map { $0 } -%>

<%_ for type in all { -%><%_ -%>
<%_ let autoMockable: Bool = type.inheritedTypes.contains("AutoMockable") || type.annotations["AutoMockable"] != nil
    let protocolToDecorate = types.protocols.first(where: { $0.name == (type.annotations["mock"] as? String) })
    let inlineMockable = protocolToDecorate != nil
    guard let aProtocol = autoMockable ? type : protocolToDecorate else { continue }
    let associatedTypes: [String]? = {
        if let types = aProtocol.annotations["associatedtype"] as? [String] {
            return types.reversed()
        } else if let type = aProtocol.annotations["associatedtype"] as? String {
            return [type]
        } else {
            return nil
        }
    }()
    let genericTypesModifier: String = {
        guard let all = associatedTypes else { return "" }
        let joined = all.flatMap {
            $0.replacingOccurrences(of: " ", with: "").characters.split(separator: ":").map(String.init).first
        }.map { "Type\($0)" }
        .joined(separator: ",")
        return "<\(joined)>"
    }()
    let genericTypesTypealiases: String = {
        guard let all = associatedTypes else { return "" }
        let joined = all.flatMap {
            $0.replacingOccurrences(of: " ", with: "").characters.split(separator: ":").map(String.init).first
        }.map { "\ttypealias \($0) = Type\($0)\n" }
        .joined(separator: "")
        return "\n\(joined)\n"
    }()
    let genericTypesConstraints: String = {
        guard let all = associatedTypes else { return "" }
        let constraints = all.flatMap { t -> String? in
            let constraint = t.replacingOccurrences(of: " ", with: "").characters.split(separator: ":").map(String.init)
            guard constraint.count == 2 else { return nil }

            let adopts = constraint[1].characters.split(separator: ",").map(String.init)

            return adopts.map {
                return "Type\(constraint[0]): \($0)"
            }.joined(separator: ", ")
        }
        .joined(separator: ", ")
        guard !constraints.isEmpty else { return "" }
        return " where \(constraints)"
    }()
    let allVariables = uniques(variables: aProtocol.allVariables.filter({ !$0.isStatic }))
    let containsVariables = !allVariables.isEmpty
    let allStaticVariables = uniques(variables: aProtocol.allVariables.filter({ $0.isStatic }))
    let containsStaticVariables = !allStaticVariables.isEmpty
    let allMethods = uniques(methods: aProtocol.allMethods.filter({ !$0.isStatic }))
    let allStaticMethods = uniques(methods: aProtocol.allMethods.filter({ $0.isStatic }))
    let conformsToStaticMock = !allStaticMethods.isEmpty || !allStaticVariables.isEmpty
    let conformsToMock = !allMethods.isEmpty || !allVariables.isEmpty -%><%_ -%><%_ -%>
<%_ if autoMockable { -%>
// MARK: - <%= type.name %>
class <%= type.name %>Mock<%= genericTypesModifier %>:<%= type.annotations["ObjcProtocol"] != nil ? " NSObject," : "" %> <%= type.name %>, Mock<%= conformsToStaticMock ? ", StaticMock" : "" %><%= genericTypesConstraints %> {
<%_ } else { -%>
// sourcery:inline:auto:<%= type.name %>.autoMocked
<%_ } -%>
<%# ================================================== MAIN CLASS -%><%_ -%>
  <%# ================================================== MOCK INTERNALS -%><%_ -%>
    <%_ %><%= genericTypesTypealiases -%>
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    var matcher: Matcher = Matcher.default
    <%_ -%>
  <%# ================================================== STATIC MOCK INTERNALS -%><%_ -%>
    <%_ if conformsToStaticMock { -%>
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    static var matcher: Matcher = Matcher.default
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }
    <%_  } -%>

  <%# ================================================== VARIABLES -%><%_ -%>
    <%_ for variable in allVariables { -%>
    <%= stubProperty(variable,"\(type.name)Mock") %>
    <%_ } %> <%_ -%>

    <%_ if containsVariables { -%>
    struct Property {
        fileprivate var method: MethodType
        <%_ for variable in allVariables { -%>
        <%= propertyTypes(variable) %>
        <%_ } %> <%_ -%>
    }
    <%_ } else { %> <%_ -%>
    typealias Property = Swift.Never
    <%_ } %> <%_ -%>
  <%# ================================================== STATIC VARIABLES -%><%_ -%>
    <%_ for variable in allStaticVariables { -%>
    <%= stubProperty(variable,"\(type.name)Mock") %>
    <%_ } %> <%_ -%>

    <%_ if containsStaticVariables { -%>
    struct StaticProperty {
        fileprivate var method: StaticMethodType
        <%_ for variable in allStaticVariables { -%>
        <%= propertyTypes(variable) %>
        <%_ } %> <%_ -%>
    }
    <%_ } else if conformsToStaticMock { %> <%_ -%>
    typealias StaticProperty = Swift.Never
    <%_ } %> <%_ -%>
  <%# ================================================== METHOD REGISTRATIONS -%><%_ -%>
    <%_ MethodWrapper.clear() -%>
    <%_ Current.selfType = "\(type.name)Mock\(genericTypesModifier)" -%>
    <%_ let wrappedMethods = allMethods.map(wrapMethod).filter({ $0.wrappedInMethodType() }) -%>
    <%_ let wrappedInitializers = allMethods.map(wrapMethod).filter({ $0.method.isInitializer }) -%>
    <%_ let wrappedStaticMethods = allStaticMethods.map(wrapMethod).filter({ $0.wrappedInMethodType() }) -%>
    <%_ for variable in allVariables { propertyRegister(variable) } -%>
    <%_ for variable in allStaticVariables { propertyRegister(variable) } -%>
    <%_ for method in wrappedMethods { method.register() } -%>
    <%_ for method in wrappedStaticMethods { method.register() } -%><%_ -%>

  <%# ================================================== STATIC STUBS -%><%_ -%>
    <%_ for method in wrappedStaticMethods { -%>
    <%= method.functionPrototype _%> {
        <%= method.stubBody() _%>
    }

    <%_ } %><%_ -%>
    <%_ -%>
  <%# ================================================== INITIALIZERS -%><%_ -%>
    <%_ for method in wrappedInitializers { -%>
    <%= method.functionPrototype _%> { }

    <%_ } -%><%_ -%>
    <%_ -%><%_ -%>
  <%# ================================================== STUBS -%><%_ -%>
    <%_ for method in wrappedMethods { -%>
    <%= method.functionPrototype _%> {
        <%= method.stubBody() _%>
    }

    <%_ } -%>
  <%# ================================================== STATIC METHOD TYPE -%><%_ -%>
    <%_ if conformsToStaticMock { -%>
    fileprivate enum StaticMethodType {
    <%_ for method in wrappedStaticMethods { -%>
        case <%= method.methodTypeDeclarationWithParameters() _%>
    <%_  } %>
    <%_ for variable in allStaticVariables { -%>
        <%= propertyMethodTypes(variable) %>
    <%_ } %> <%_ %>
    <%_ -%>
        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) { <%_ for method in wrappedStaticMethods { %>
                <%= method.equalCase -%><% for parameter in method.parameters { %>
                    <%= parameter.comparator -%> <%  } %>
                    return true <% } %>
                <%_ for variable in allStaticVariables { -%>
                <%= propertyMethodTypesCompare(variable) %>
                <%_ } %> <%_ -%>
                <%_ if wrappedStaticMethods.count + 2 * allStaticVariables.count > 1 { -%>
                default: return false
                <%_ } -%>
            }
        }
    <%_ %>
        func intValue() -> Int {
            switch self { <%_ for method in wrappedStaticMethods { %>
                <%= method.intValueCase -%><% } %>
                <%_ for variable in allStaticVariables { -%>
                <%= propertyMethodTypesIntValue(variable) %>
                <%_ } %> <%_ -%>
            }
        }
    }

    struct StaticGiven {
        fileprivate var method: StaticMethodType
        var returns: Any?
        var `throws`: Error?

        private init(method: StaticMethodType, returns: Any?, throws: Error?) {
            self.method = method
            self.returns = returns
            self.`throws` = `throws`
        }

        <%_ for method in wrappedStaticMethods.filter({ !$0.method.returnTypeName.isVoid && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorName(prefix: "Static") -%> {
            <%= method.givenConstructor(prefix: "Static") _%>
        }
        <%_ } -%>
        <%_ for method in wrappedStaticMethods.filter({ ($0.method.throws || $0.method.rethrows) && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorNameThrows(prefix: "Static") -%> {
            <%= method.givenConstructorThrows(prefix: "Static") _%>
        }
        <%_  } %> <%_ -%>
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        <%_ for method in wrappedStaticMethods { -%>
        <%= method.verificationProxyConstructorName(prefix: "Static") -%> {
            <%= method.verificationProxyConstructor(prefix: "Static") _%>
        }
        <%_  } %> <%_ -%>
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        <%_ for method in wrappedStaticMethods { -%>
        <%= method.performProxyConstructorName(prefix: "Static") -%> {
            <%= method.performProxyConstructor(prefix: "Static") _%>
        }
        <%_  } %> <%_ -%>
    }

    <% } -%>
  <%# ================================================== METHOD TYPE -%><%_ -%>
    <%_ if !wrappedMethods.isEmpty || !allVariables.isEmpty { -%>
    fileprivate enum MethodType {
    <%_ for method in wrappedMethods { -%>
        case <%= method.methodTypeDeclarationWithParameters() _%>
    <%_  } -%>
    <%_ for variable in allVariables { -%>
        <%= propertyMethodTypes(variable) %>
    <%_ } %> <%_ %>
    <%_ -%>
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) { <%_ for method in wrappedMethods { %>
                <%= method.equalCase -%><% for parameter in method.parameters { %>
                    <%= parameter.comparator -%> <%  } %>
                    return true <% } %>
                <%_ for variable in allVariables { -%>
                <%= propertyMethodTypesCompare(variable) %>
                <%_ } %> <%_ -%>
                <%_ if wrappedMethods.count + 2 * allVariables.count > 1 { -%>
                default: return false
                <%_ } -%>
            }
        }
    <%_ %>
        func intValue() -> Int {
            switch self { <%_ for method in wrappedMethods { %>
                <%= method.intValueCase -%><% } %>
                <%_ for variable in allVariables { -%>
                <%= propertyMethodTypesIntValue(variable) %>
                <%_ } %> <%_ -%>
            }
        }
    }
    <%_ } else { %>
    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }
    <%_ } -%><%_ -%>

    struct Given {
        fileprivate var method: MethodType
        var returns: Any?
        var `throws`: Error?

        private init(method: MethodType, returns: Any?, throws: Error?) {
            self.method = method
            self.returns = returns
            self.`throws` = `throws`
        }

        <%_ for method in wrappedMethods.filter({ !$0.method.returnTypeName.isVoid && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorName() -%> {
            <%= method.givenConstructor() _%>
        }
        <%_ } -%>
        <%_ for method in wrappedMethods.filter({ ($0.method.throws || $0.method.rethrows) && !$0.method.isInitializer }) { -%>
        <%= method.givenConstructorNameThrows() -%> {
            <%= method.givenConstructorThrows() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Verify {
        fileprivate var method: MethodType

        <%_ for method in wrappedMethods { -%>
        <%= method.verificationProxyConstructorName() -%> {
            <%= method.verificationProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        <%_ for method in wrappedMethods { -%>
        <%= method.performProxyConstructorName() -%> {
            <%= method.performProxyConstructor() _%>
        }
        <%_  } %> <%_ -%>
    }

  <%# ================================================== MOCK METHODS -%><%_ -%>
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
        methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expeced: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }
    <%_ if containsVariables { -%>

    public func verify(property: Property, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(property.method)
        MockyAssert(count.matches(invocations.count), "Expeced: \(count) invocations of `\(property.method)`, but was: \(invocations.count)", file: file, line: line)
    }
    <%_ } else { -%>
    public func verify(property: Property, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) { }
    <%_ } -%>

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }

    private func methodReturnValue(_ method: MethodType) -> (value: Any?, error: Error?) {
        let matched = methodReturnValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher)  }
        return (value: matched?.returns, error: matched?.`throws`)
    }

    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }

    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
  <%# ================================================== STATIC MOCK METHODS -%><%_ -%>
    <%_ if conformsToStaticMock { -%>

    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
        methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expeced: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }
    <%_ if containsStaticVariables { -%>

    static public func verify(property: StaticProperty, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(property.method)
        MockyAssert(count.matches(invocations.count), "Expeced: \(count) invocations of `\(property.method)`, but was: \(invocations.count)", file: file, line: line)
    }
    <%_ } else { -%>
    static public func verify(property: StaticProperty, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) { }
    <%_ } -%>

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }

    static private func methodReturnValue(_ method: StaticMethodType) -> (value: Any?, error: Error?) {
        let matched = methodReturnValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher)  }
        return (value: matched?.returns, error: matched?.`throws`)
    }

    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }

    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    <%_ } -%>
<%_ if autoMockable { -%>
}

<%_ } else { -%>
// sourcery:end
<%_ } -%>
<% } -%>
